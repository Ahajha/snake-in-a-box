/*
This program counts the number of canonical forms generated by siab2, and
by a modified version that prunes some forms. The results are printed in
a format that can be easily pasted into Desmos for viewing. (The log of the
result is given, since the raw numbers are too large to get an interpretable
graph.)

Each form has a 'footprint', the set of vertices that are induced, invalided,
or blocked from being reached from the current endpoint. Equivalently,
the inverse of the footprint is any vertex that could still potentially be
added/visited.

Forms can be compared via a partial ordering of their footprints.
Given two forms F and G and their footprints X and Y:
if X is a subset of Y then F <= G (F < G if a proper subset)
if X == Y then F == G (not the same form, but have the same expansion options)
if X is not a subset of Y, and Y is not a subset of X, then F and G are unordered.

Forms are grouped by number of vertices and current endpoint. From there, remove
any forms that have a smaller form, and keep only one copy of equivalent forms.
*/

#include <array>
#include <stack>
#include <ctime>
#include <vector>
#include <bitset>
#include <iostream>
#include "hypercube.hpp"
#include "permutation.hpp"

// MAX_DIM will be compiled in

constexpr unsigned numVertices = 1 << MAX_DIM;

struct snake
{
	hypercube<MAX_DIM> h;
	
	std::bitset<numVertices> footprint;
	
	unsigned highestDim;
	
	// Looks at the current state of h to construct a snake.
	snake(const hypercube<MAX_DIM>& _h, unsigned lastAddition, unsigned highestDimension)
		: h(_h), highestDim(highestDimension)
	{
		// DFS search
		std::stack<unsigned> toBeSearched;
		
		// Start as true, set any vertices that can be reached to false.
		footprint.set();
		
		for (unsigned adj : hypercube<MAX_DIM>::adjLists[lastAddition])
		{
			if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
			{
				toBeSearched.push(adj);
			}
		}
		
		while(!toBeSearched.empty())
		{
			unsigned next = toBeSearched.top();
			toBeSearched.pop();
			
			if (footprint[next])
			{
				footprint.reset(next);
				
				for (unsigned adj : hypercube<MAX_DIM>::adjLists[next])
				{
					if (h.vertices[adj].effectiveDegree == 0 && !h.vertices[adj].induced)
					{
						toBeSearched.push(adj);
					}
				}
			}
		}
	}
	
	friend std::ostream& operator<<(std::ostream& stream, const snake& s)
	{
		stream << s.h;
		for (unsigned i = 0; i < numVertices; ++i)
		{
			stream << (s.footprint[i] ? 'O' : '_') << ' ';
		}
		return stream << "| highest dim = " << s.highestDim;
	}
	
	std::partial_ordering operator<=>(const snake& other) const
	{
		bool thisSmaller  = (~footprint |= other.footprint).all();
		bool otherSmaller = (~other.footprint |= footprint).all();
		
		constexpr static std::partial_ordering results[] =
		{
			std::partial_ordering::unordered, // Index 0, both false
			std::partial_ordering::less,      // Index 1, thisSmaller
			std::partial_ordering::greater,   // Index 2, otherSmaller
			std::partial_ordering::equivalent // Index 3, both true
		};
		
		// This calculation maps each pair of boolean values to a unique
		// index, (0 to 3) then returns the result from there. This avoids
		// branching, which could be slow.
		return results[(unsigned)thisSmaller + (otherSmaller << 1)];
	}
};

// First index is # of vertices, second is end vertex, last vector contains snakes.
std::array<std::array<std::vector<snake>,numVertices>,numVertices + 1> snakeClasses;

void emplaceSnake(const hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	snake s(h,lastAddition, highestDim);
	
	auto& snakeClass = snakeClasses[h.numInduced][lastAddition];
	
	// Find the first element that does not compare unordered to s.
	// Default value needed due to no default constructor.
	std::partial_ordering result = std::partial_ordering::unordered;
	
	auto iter = std::find_if(snakeClass.begin(), snakeClass.end(),
		[&result, &s](const snake& other)
		{
			return (result = s <=> other) != std::partial_ordering::unordered;
		}
	);
	
	// If there is no such element, add s to the vector
	if (iter == snakeClass.end())
	{
		snakeClass.emplace_back(s);
	}
	
	// If s is smaller than the given element, replace it
	else if (result == std::partial_ordering::less)
	{
		*iter = s;
		
		// Erase any other values that are larger than s.
		// Use iter + 1, since we don't want to replace s.
		snakeClass.erase(
			std::remove_if(iter + 1, snakeClass.end(), [&s](const snake& other)
			{
				return s <= other;
			}
		), snakeClass.end());
	}
}

std::array<unsigned long long, numVertices + 1> sizeCounts;

unsigned long long getSnakesOfSize(unsigned size)
{
	if (sizeCounts[size]) return sizeCounts[size];
	
	unsigned long long result = 0;
	for (const auto& snakeClass : snakeClasses[size])
	{
		result += snakeClass.size();
	}
	return result;
}

unsigned breakPoint;

void enumerateRecursive(hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	++sizeCounts[h.numInduced];
	
	if (h.numInduced == breakPoint) return;
	
	// By the nature of the order of the vertices, index in the adjacency
	// list is also the dimension number.
	const unsigned stop = std::min((unsigned)MAX_DIM,highestDim + 1);
	for (unsigned i = 0; i < stop; ++i)
	{
		unsigned adj = hypercube<MAX_DIM>::adjLists[lastAddition][i];
		
		// We need to check that the neighbor isn't induced specifically
		// for the case of the starting vertex's first expansion.
		if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
		{
			h.induce(adj);
			
			enumerateRecursive(h, adj, highestDim + (i == highestDim));
			
			h.reduce(adj);
		}
	}
}

void enumerate(hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	// By the nature of the order of the vertices, index in the adjacency
	// list is also the dimension number.
	const unsigned stop = std::min((unsigned)MAX_DIM,highestDim + 1);
	for (unsigned i = 0; i < stop; ++i)
	{
		unsigned adj = hypercube<MAX_DIM>::adjLists[lastAddition][i];
		
		// We need to check that the neighbor isn't induced specifically
		// for the case of the starting vertex's first expansion.
		if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
		{
			h.induce(adj);
			
			emplaceSnake(h, adj, highestDim + (i == highestDim));
			
			h.reduce(adj);
		}
	}
}

int main(int argn, char** args)
{
	if (argn != 3)
	{
		std::cerr << "Error: requires 'pruned' and 'semipruned' as arguments"
			<< std::endl;
		return 1;
	}
	
	const unsigned pruned = atoi(args[1]);
	breakPoint = atoi(args[2]);
	
	auto start_time = clock();
	
	// Enumerate pruned first
	hypercube<MAX_DIM> h;
	h.induce(0);
	
	emplaceSnake(h,0,0);
	
	for (unsigned nv = 0; nv < pruned && nv <= numVertices; ++nv)
	{
		for (unsigned endpoint = 0; endpoint < snakeClasses[nv].size(); ++endpoint)
		{
			for (auto& s : snakeClasses[nv][endpoint])
			{
				enumerate(s.h, endpoint, s.highestDim);
			}
		}
		
		unsigned result = getSnakesOfSize(nv);
		if (result)
			std::cout << nv << ": " << result << std::endl;
	}
	
	if (pruned <= numVertices)
	{
		for (unsigned endpoint = 0; endpoint < numVertices; ++endpoint)
		{
			for (auto& s : snakeClasses[pruned][endpoint])
			{
				enumerateRecursive(s.h, endpoint, s.highestDim);
			}
		}
		
		for (unsigned nv = pruned; nv < snakeClasses.size(); ++nv)
		{
			unsigned result = getSnakesOfSize(nv);
			if (result)
				std::cout << nv << ": " << result << std::endl;
		}
	}
	
	std::cout << "Finished in " << (float)(clock()-start_time)/(CLOCKS_PER_SEC) << " seconds\n";
	
	// Print in graph-friendly format
	unsigned long long total = 0;
	for (unsigned nv = 0; nv < snakeClasses.size(); ++nv)
	{
		unsigned result = getSnakesOfSize(nv);
		total += result;
		if (result)
			std::cout << '(' << nv << ",log(" << result << ")),";
	}
	std::cout << "\b \n\nTotal = " << total << std::endl;
	std::cout << '(' << MAX_DIM << ",log(" << total << "))" << std::endl;
}
