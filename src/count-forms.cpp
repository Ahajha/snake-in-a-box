/*
This program counts the number of canonical forms generated by siab2, and
by a modified version that prunes some forms. The results are printed in
a format that can be easily pasted into Desmos for viewing. (The log of the
result is given, since the raw numbers are too large to get an interpretable
graph.)

Each form has a 'footprint', the set of vertices that are induced, invalided,
or blocked from being reached from the current endpoint. Equivalently,
the inverse of the footprint is any vertex that could still potentially be
added/visited.

Forms can be compared via a partial ordering of their footprints.
Given two forms F and G and their footprints X and Y:
if X is a subset of Y then F <= G (F < G if a proper subset)
if X == Y then F == G (not the same form, but have the same expansion options)
if X is not a subset of Y, and Y is not a subset of X, then F and G are unordered.

Forms are grouped by number of vertices and current endpoint. From there, remove
any forms that have a smaller form, and keep only one copy of equivalent forms.

Dimension may also need to be considered, there has been an instance of running a
prototype of this program where the result was incorrect on N = 6 (only got to 26)
*/

#include <array>
#include <stack>
#include <vector>
#include <iostream>
#include <unordered_set>
#include "hypercube.hpp"
#include "permutation.hpp"

// MAX_DIM will be compiled in

constexpr unsigned numVertices = 1 << MAX_DIM;

struct snake
{
	hypercube<MAX_DIM> _h;
	
	std::array<bool,numVertices> footprint;
	
	unsigned highestDim;
	
	// Looks at the current state of h to construct a snake.
	snake(const hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDimension)
		: _h(h), highestDim(highestDimension)
	{
		// DFS search
		std::stack<unsigned> toBeSearched;
		
		// Start as true, set any vertices that can be reached to false.
		footprint.fill(true);
		
		for (unsigned adj : hypercube<MAX_DIM>::adjLists[lastAddition])
		{
			if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
			{
				toBeSearched.push(adj);
			}
		}
		
		while(!toBeSearched.empty())
		{
			unsigned next = toBeSearched.top();
			toBeSearched.pop();
			
			if (footprint[next])
			{
				footprint[next] = false;
				
				for (unsigned adj : hypercube<MAX_DIM>::adjLists[next])
				{
					if (h.vertices[adj].effectiveDegree == 0 && !h.vertices[adj].induced)
					{
						toBeSearched.push(adj);
					}
				}
			}
		}
	}
	
	friend std::ostream& operator<<(std::ostream& stream, const snake& s)
	{
		stream << s._h;
		for (bool f : s.footprint)
		{
			stream << (f ? 'O' : '_') << ' ';
		}
		return stream << "| highest dim = " << s.highestDim;
	}
	
	std::partial_ordering operator<=>(const snake& other) const
	{
		bool thisSmaller = true, otherSmaller = true;
		
		for (unsigned i = 0; i < numVertices; ++i)
		{
			if (footprint[i] != other.footprint[i])
			{
				if (footprint[i])
				{
					thisSmaller = false;
					
					if (!otherSmaller)
					{
						return std::partial_ordering::unordered;
					}
				}
				else // other.footprint[i]
				{
					otherSmaller = false;
					
					if (!thisSmaller)
					{
						return std::partial_ordering::unordered;
					}
				}
			}
		}
		
		if (thisSmaller)
		{
			if (otherSmaller)
			{
				return std::partial_ordering::equivalent;
			}
			else
			{
				return std::partial_ordering::less;
			}
		}
		else
		{
			return std::partial_ordering::greater;
		}
	}
};

// First index is # of vertices, second is end vertex, last vector contains snakes.
std::array<std::array<std::vector<snake>,numVertices>,numVertices + 1> snakeClasses;

void emplaceSnake(const hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	snake s(h,lastAddition, highestDim);
	
	auto& snakeClass = snakeClasses[h.numInduced][lastAddition];
	
	// Find the first element that does not compare unordered to s.
	// Default value needed due to no default constructor.
	std::partial_ordering result = std::partial_ordering::unordered;
	
	auto iter = std::find_if(snakeClass.begin(), snakeClass.end(),
		[&result, &s](const snake& other)
		{
			return (result = s <=> other) != std::partial_ordering::unordered;
		}
	);
	
	// If there is no such element, add s to the vector
	if (iter == snakeClass.end())
	{
		snakeClass.emplace_back(s);
	}
	
	// If s is smaller than the given element, replace it
	else if (result == std::partial_ordering::less)
	{
		*iter = s;
		
		// Erase any other values that are larger than s.
		// Use iter + 1, since we don't want to replace s.
		snakeClass.erase(
			std::remove_if(iter + 1, snakeClass.end(), [&s](const snake& other)
			{
				return s <= other;
			}
		), snakeClass.end());
	}
}

std::array<unsigned long long, numVertices + 1> sizeCounts;

unsigned long long getSnakesOfSize(unsigned size)
{
	if (sizeCounts[size]) return sizeCounts[size];
	
	unsigned long long result = 0;
	for (const auto& snakeClass : snakeClasses[size])
	{
		result += snakeClass.size();
	}
	return result;
}

unsigned breakPoint;

void enumerateRecursive(hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	++sizeCounts[h.numInduced];
	
	if (h.numInduced == breakPoint) return;
	
	// By the nature of the order of the vertices, index in the adjacency
	// list is also the dimension number.
	const unsigned stop = std::min((unsigned)MAX_DIM,highestDim + 1);
	for (unsigned i = 0; i < stop; ++i)
	{
		unsigned adj = hypercube<MAX_DIM>::adjLists[lastAddition][i];
		
		// We need to check that the neighbor isn't induced specifically
		// for the case of the starting vertex's first expansion.
		if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
		{
			h.induce(adj);
			
			enumerateRecursive(h, adj, highestDim + (i == highestDim));
			
			h.reduce(adj);
		}
	}
}

void enumerate(hypercube<MAX_DIM>& h, unsigned lastAddition, unsigned highestDim)
{
	// By the nature of the order of the vertices, index in the adjacency
	// list is also the dimension number.
	const unsigned stop = std::min((unsigned)MAX_DIM,highestDim + 1);
	for (unsigned i = 0; i < stop; ++i)
	{
		unsigned adj = hypercube<MAX_DIM>::adjLists[lastAddition][i];
		
		// We need to check that the neighbor isn't induced specifically
		// for the case of the starting vertex's first expansion.
		if (h.vertices[adj].effectiveDegree == 1 && !h.vertices[adj].induced)
		{
			h.induce(adj);
			
			emplaceSnake(h, adj, highestDim + (i == highestDim));
			
			h.reduce(adj);
		}
	}
}

int main(int argn, char** args)
{
	if (argn != 3)
	{
		std::cerr << "Error: requires 'pruned' and 'semipruned' as arguments"
			<< std::endl;
		return 1;
	}
	
	const unsigned pruned = atoi(args[1]);
	breakPoint = atoi(args[2]);
	
	// Enumerate pruned first
	hypercube<MAX_DIM> h;
	h.induce(0);
	
	emplaceSnake(h,0,0);
	
	for (unsigned nv = 0; nv < pruned && nv <= numVertices; ++nv)
	{
		for (unsigned endpoint = 0; endpoint < snakeClasses[nv].size(); ++endpoint)
		{
			for (auto& s : snakeClasses[nv][endpoint])
			{
				enumerate(s._h, endpoint, s.highestDim);
			}
		}
		
		unsigned result = getSnakesOfSize(nv);
		if (result)
			std::cout << nv << ": " << result << std::endl;
	}
	
	if (pruned <= numVertices)
	{
		for (unsigned endpoint = 0; endpoint < numVertices; ++endpoint)
		{
			for (auto& s : snakeClasses[pruned][endpoint])
			{
				enumerateRecursive(s._h, endpoint, s.highestDim);
			}
		}
		
		for (unsigned nv = pruned; nv < snakeClasses.size(); ++nv)
		{
			unsigned result = getSnakesOfSize(nv);
			if (result)
				std::cout << nv << ": " << result << std::endl;
		}
	}
	
	// Print in graph-friendly format
	for (unsigned nv = 0; nv < snakeClasses.size(); ++nv)
	{
		unsigned result = getSnakesOfSize(nv);
		if (result)
			std::cout << '(' << nv << ",log(" << result << ")),";
	}
	std::cout << "\b \n";
}
